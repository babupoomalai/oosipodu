{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.loadWasmInstance = void 0;\n/**\n * Webpack File-loader will break when the extension is .wasm.\n * Changing the extension is a workaround. And because of this\n * |instantiateStreaming| is always failed due to wrong MIME type.\n * see https://github.com/webpack/webpack/issues/6725\n */\n// import wasmBinaryFile from './zbar.wasm';\n\nconst zbar_wasm_bin_1 = __importDefault(require(\"./zbar.wasm.bin\"));\n\nexports.loadWasmInstance = async importObj => {\n  // try {\n  //   const output = await WebAssembly.instantiateStreaming(\n  //     fetch(wasmBinaryFile),\n  //     importObj\n  //   );\n  //   return output.instance;\n  // } catch (err) {\n  //   console.error('Wasm streaming compile failed: ' + err);\n  //   console.error('Falling back to ArrayBuffer instantiation');\n  // }\n  const res = await fetch(zbar_wasm_bin_1.default);\n\n  if (!res['ok']) {\n    console.error('Failed to load wasm binary file at ' + zbar_wasm_bin_1.default);\n    return null;\n  }\n\n  const binary = await res.arrayBuffer();\n  const output = await WebAssembly.instantiate(binary, importObj);\n  return output.instance;\n};","map":{"version":3,"sources":["../src/load-browser.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA;;;;;AAKG;AACH;;AACA,MAAA,eAAA,GAAA,eAAA,CAAA,OAAA,CAAA,iBAAA,CAAA,CAAA;;AAEa,OAAA,CAAA,gBAAA,GAAmB,MAC9B,SAD8B,IAEU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAM,GAAG,GAAG,MAAM,KAAK,CAAC,eAAA,CAAA,OAAD,CAAvB;;AACA,MAAI,CAAC,GAAG,CAAC,IAAD,CAAR,EAAgB;AACd,IAAA,OAAO,CAAC,KAAR,CAAc,wCAAwC,eAAA,CAAA,OAAtD;AACA,WAAO,IAAP;AACD;;AACD,QAAM,MAAM,GAAG,MAAM,GAAG,CAAC,WAAJ,EAArB;AACA,QAAM,MAAM,GAAG,MAAM,WAAW,CAAC,WAAZ,CAAwB,MAAxB,EAAgC,SAAhC,CAArB;AACA,SAAO,MAAM,CAAC,QAAd;AACD,CArBY","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.loadWasmInstance = void 0;\n/**\n * Webpack File-loader will break when the extension is .wasm.\n * Changing the extension is a workaround. And because of this\n * |instantiateStreaming| is always failed due to wrong MIME type.\n * see https://github.com/webpack/webpack/issues/6725\n */\n// import wasmBinaryFile from './zbar.wasm';\nconst zbar_wasm_bin_1 = __importDefault(require(\"./zbar.wasm.bin\"));\nexports.loadWasmInstance = async (importObj) => {\n    // try {\n    //   const output = await WebAssembly.instantiateStreaming(\n    //     fetch(wasmBinaryFile),\n    //     importObj\n    //   );\n    //   return output.instance;\n    // } catch (err) {\n    //   console.error('Wasm streaming compile failed: ' + err);\n    //   console.error('Falling back to ArrayBuffer instantiation');\n    // }\n    const res = await fetch(zbar_wasm_bin_1.default);\n    if (!res['ok']) {\n        console.error('Failed to load wasm binary file at ' + zbar_wasm_bin_1.default);\n        return null;\n    }\n    const binary = await res.arrayBuffer();\n    const output = await WebAssembly.instantiate(binary, importObj);\n    return output.instance;\n};\n//# sourceMappingURL=load-browser.js.map"]},"metadata":{},"sourceType":"script"}