{"ast":null,"code":"/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nmodule.exports = class LinkedDataProof {\n  constructor({\n    type\n  } = {}) {\n    if (typeof type !== 'string') {\n      throw new TypeError('A LinkedDataProof must have a \"type\".');\n    }\n\n    this.type = type;\n  }\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n\n\n  async createProof({\n    document,\n    purpose,\n    documentLoader,\n    expansionMap,\n    compactProof\n  }) {\n    throw new Error('\"createProof\" must be implemented in a derived class.');\n  }\n  /**\n   * @param proof {object} the proof to be verified.\n   * @param document {object} the document the proof applies to.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n\n\n  async verifyProof({\n    proof,\n    document,\n    purpose,\n    documentLoader,\n    expansionMap\n  }) {\n    throw new Error('\"verifyProof\" must be implemented in a derived class.');\n  }\n  /**\n   * @param proof {object} the proof to be matched.\n   * @param document {object} the document the proof applies to.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{boolean}>} Resolves with the verification result.\n   */\n\n\n  async matchProof({\n    proof,\n    document,\n    purpose,\n    documentLoader,\n    expansionMap\n  }) {\n    return proof.type === this.type;\n  }\n\n};","map":{"version":3,"sources":["/Users/bpoomalai/Documents/babu/cowin/egovernments DIVOC india verification/node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js"],"names":["module","exports","LinkedDataProof","constructor","type","TypeError","createProof","document","purpose","documentLoader","expansionMap","compactProof","Error","verifyProof","proof","matchProof"],"mappings":"AAAA;AACA;AACA;AACA;;AAEAA,MAAM,CAACC,OAAP,GAAiB,MAAMC,eAAN,CAAsB;AACrCC,EAAAA,WAAW,CAAC;AAACC,IAAAA;AAAD,MAAS,EAAV,EAAc;AACvB,QAAG,OAAOA,IAAP,KAAgB,QAAnB,EAA6B;AAC3B,YAAM,IAAIC,SAAJ,CAAc,uCAAd,CAAN;AACD;;AACD,SAAKD,IAAL,GAAYA,IAAZ;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACmB,QAAXE,WAAW,CACf;AAACC,IAAAA,QAAD;AAAWC,IAAAA,OAAX;AAAoBC,IAAAA,cAApB;AAAoCC,IAAAA,YAApC;AAAkDC,IAAAA;AAAlD,GADe,EACkD;AACjE,UAAM,IAAIC,KAAJ,CAAU,uDAAV,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACmB,QAAXC,WAAW,CAAC;AAACC,IAAAA,KAAD;AAAQP,IAAAA,QAAR;AAAkBC,IAAAA,OAAlB;AAA2BC,IAAAA,cAA3B;AAA2CC,IAAAA;AAA3C,GAAD,EAA2D;AAC1E,UAAM,IAAIE,KAAJ,CAAU,uDAAV,CAAN;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACkB,QAAVG,UAAU,CAAC;AAACD,IAAAA,KAAD;AAAQP,IAAAA,QAAR;AAAkBC,IAAAA,OAAlB;AAA2BC,IAAAA,cAA3B;AAA2CC,IAAAA;AAA3C,GAAD,EAA2D;AACzE,WAAOI,KAAK,CAACV,IAAN,KAAe,KAAKA,IAA3B;AACD;;AA9CoC,CAAvC","sourcesContent":["/*!\n * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nmodule.exports = class LinkedDataProof {\n  constructor({type} = {}) {\n    if(typeof type !== 'string') {\n      throw new TypeError('A LinkedDataProof must have a \"type\".');\n    }\n    this.type = type;\n  }\n\n  /**\n   * @param document {object} to be signed.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   * @param compactProof {boolean}\n   *\n   * @returns {Promise<object>} Resolves with the created proof object.\n   */\n  async createProof(\n    {document, purpose, documentLoader, expansionMap, compactProof}) {\n    throw new Error('\"createProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * @param proof {object} the proof to be verified.\n   * @param document {object} the document the proof applies to.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{object}>} Resolves with the verification result.\n   */\n  async verifyProof({proof, document, purpose, documentLoader, expansionMap}) {\n    throw new Error('\"verifyProof\" must be implemented in a derived class.');\n  }\n\n  /**\n   * @param proof {object} the proof to be matched.\n   * @param document {object} the document the proof applies to.\n   * @param purpose {ProofPurpose}\n   * @param documentLoader {function}\n   * @param expansionMap {function}\n   *\n   * @returns {Promise<{boolean}>} Resolves with the verification result.\n   */\n  async matchProof({proof, document, purpose, documentLoader, expansionMap}) {\n    return proof.type === this.type;\n  }\n};\n"]},"metadata":{},"sourceType":"script"}